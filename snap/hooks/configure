#!/usr/bin/env bash

set -eux

source $SNAP/actions/common/utils.sh

# This is a one-off patch. It will allow us to refresh the beta snap without breaking the user's deployment.
# We make sure the certificates used by the deployment from beta do not change. We copy them to SNAP_DATA
# and make sure the respective services use them.
# Without this patch the user would have to remove and reainstall microk8s.
# This patch can be removed at a later stage.
if [ ! -d ${SNAP_DATA}/certs ] && grep -e "\-\-client-ca-file=\${SNAP}/certs/ca.crt" ${SNAP_DATA}/args/kube-apiserver
then
  echo "Patching certificates location"
  mkdir -p ${SNAP_DATA}/certs
  cp -r ${SNAP}/certs-beta/* ${SNAP_DATA}/certs/
  "$SNAP/bin/sed" -i 's@\${SNAP}/certs/ca.crt@\${SNAP_DATA}/certs/ca.crt@g' ${SNAP_DATA}/args/kube-apiserver
  "$SNAP/bin/sed" -i 's@\${SNAP}/certs/server.key@\${SNAP_DATA}/certs/server.key@g' ${SNAP_DATA}/args/kube-apiserver
  "$SNAP/bin/sed" -i 's@\${SNAP}/certs/server.crt@\${SNAP_DATA}/certs/server.crt@g' ${SNAP_DATA}/args/kube-apiserver
  "$SNAP/bin/sed" -i 's@\${SNAP}/certs/serviceaccount.key@\${SNAP_DATA}/certs/serviceaccount.key@g' ${SNAP_DATA}/args/kube-apiserver
  "$SNAP/bin/sed" -i 's@\${SNAP}/certs/ca.crt@\${SNAP_DATA}/certs/ca.crt@g' ${SNAP_DATA}/args/kube-controller-manager
  "$SNAP/bin/sed" -i 's@\${SNAP}/certs/serviceaccount.key@\${SNAP_DATA}/certs/serviceaccount.key@g' ${SNAP_DATA}/args/kube-controller-manager
  systemctl restart snap.${SNAP_NAME}.daemon-apiserver
  systemctl restart snap.${SNAP_NAME}.daemon-controller-manager
fi

#Allow the ability to add external IPs to the csr, by moving the csr.conf.template to SNAP_DATA 
if [ ! -f ${SNAP_DATA}/certs/csr.conf.template ]
then
   cp ${SNAP}/certs/csr.conf.template ${SNAP_DATA}/certs/csr.conf.template
fi

if ! grep "requestheader-client-ca-file" ${SNAP_DATA}/args/kube-apiserver
then
  echo "Patching requestheader-client-ca-file argument"
  # Add a new line at the end
  echo "" >> ${SNAP_DATA}/args/kube-apiserver
  echo "--requestheader-client-ca-file=\${SNAP_DATA}/certs/ca.crt" >> ${SNAP_DATA}/args/kube-apiserver
  systemctl restart snap.${SNAP_NAME}.daemon-apiserver
fi

# Patch for issue: https://github.com/ubuntu/microk8s/issues/121
if grep -e  "requestheader-client-ca-file=/var/snap/microk8s/.../certs/ca.crt"  ${SNAP_DATA}/args/kube-apiserver
then
  "$SNAP/bin/sed" -i 's@requestheader-client-ca-file=/var/snap/microk8s/.../certs/ca.crt@requestheader-client-ca-file=\${SNAP_DATA}/certs/ca.crt@g' ${SNAP_DATA}/args/kube-apiserver
fi

# Create the locks directory
mkdir -p ${SNAP_DATA}/var/lock/

# This will allow us to refresh the snap to the more secure version.
# We need to make sure the client certificate used in microk8s.kubectl is available under $SNAP_DATA
if [ ! -f ${SNAP_DATA}/credentials/client.config ]
then
  echo "Patching client config location"
  mkdir -p ${SNAP_DATA}/credentials/
  cp ${SNAP}/client.config ${SNAP_DATA}/credentials/
fi

# Upgrading to containerd
if [ ! -e ${SNAP_DATA}/args/kubectl ]
then
  echo "Making sure we have kubectl arguments file"
  cp ${SNAP}/default-args/kubectl ${SNAP_DATA}/args/kubectl
fi

# Upgrading to containerd
if [ ! -e ${SNAP_DATA}/args/containerd ]
then
  echo "Making sure we have containerd file"
  cp ${SNAP}/default-args/containerd ${SNAP_DATA}/args/containerd
  cp ${SNAP}/default-args/containerd-template.toml ${SNAP_DATA}/args/containerd-template.toml
  cp ${SNAP}/default-args/containerd-env ${SNAP_DATA}/args/containerd-env

  cp -r ${SNAP}/default-args/cni-network ${SNAP_DATA}/args/

  cp ${SNAP}/default-args/ctr ${SNAP_DATA}/args/ctr

  refresh_opt_in_config container-runtime remote kubelet
  refresh_opt_in_config container-runtime-endpoint \${SNAP_COMMON}/run/containerd.sock kubelet

  skip_opt_in_config docker-root kubelet
  skip_opt_in_config docker kubelet
  skip_opt_in_config docker-endpoint kubelet

  systemctl restart snap.${SNAP_NAME}.daemon-containerd
  systemctl restart snap.${SNAP_NAME}.daemon-kubelet

  if [ -e ${SNAP_DATA}/args/dockerd ] && grep -e "default-runtime=nvidia" ${SNAP_DATA}/args/dockerd
  then
    # Deployment used to run docker with nvidia enabled we need to enable nvidia on containerd
    # Allow for kubelet and containerd to restart
    sleep 10
    ${SNAP}/microk8s-enable.wrapper gpu
  fi

fi

# Make sure the server certificate includes the IP we are using
if ! [ -f ${SNAP_DATA}/certs/csr.conf ]
then
    produce_server_cert
    rm -rf .srl
    systemctl restart snap.${SNAP_NAME}.daemon-apiserver.service
    systemctl restart snap.${SNAP_NAME}.daemon-proxy.service
fi

# Make containerd stream server listen to localhost
if [ -e ${SNAP_DATA}/args/containerd-template.toml ] && grep -e "stream_server_address = \"\"" ${SNAP_DATA}/args/containerd-template.toml
then
    "$SNAP/bin/sed" -i 's@stream_server_address = ""@stream_server_address = "127.0.0.1"@g' ${SNAP_DATA}/args/containerd-template.toml
    if grep -e "stream_server_port = \"10010\"" ${SNAP_DATA}/args/containerd-template.toml
    then
        "$SNAP/bin/sed" -i 's@stream_server_port = "10010"@stream_server_port = "0"@g' ${SNAP_DATA}/args/containerd-template.toml
    fi
    systemctl restart snap.${SNAP_NAME}.daemon-containerd
    systemctl restart snap.${SNAP_NAME}.daemon-kubelet
fi

need_api_restart=false
if ! [ -f "$SNAP_DATA/credentials/kubelet.config" ]
then
  # Create the known tokens
  touch ${SNAP_DATA}/credentials/known_tokens.csv
  chmod 660 ${SNAP_DATA}/credentials/known_tokens.csv
  kubelet_token=$(openssl rand -base64 32 | ${SNAP}/usr/bin/base64)
  hostname=$(hostname)
  echo "${kubelet_token},system:node:${hostname},kubelet-0,\"system:nodes\"" >> ${SNAP_DATA}/credentials/known_tokens.csv
  ca_data=$(cat ${SNAP_DATA}/certs/ca.crt | ${SNAP}/usr/bin/base64 -w 0)

  cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/kubelet.config
  chmod 660 ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i 's/NAME/kubelet/g' ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/kubelet.config
  $SNAP/bin/sed -i 's/PASSWORD/'"${kubelet_token}"'/g' ${SNAP_DATA}/credentials/kubelet.config

  refresh_opt_in_config kubeconfig \${SNAP_DATA}/credentials/kubelet.config kubelet
  refresh_opt_in_config token-auth-file \${SNAP_DATA}/credentials/known_tokens.csv kube-apiserver

  systemctl restart snap.${SNAP_NAME}.daemon-kubelet
  need_api_restart=true
fi

if ! [ -f "$SNAP_DATA/credentials/proxy.config" ]
then
  # Create the known tokens
  touch ${SNAP_DATA}/credentials/known_tokens.csv
  chmod 660 ${SNAP_DATA}/credentials/known_tokens.csv
  proxy_token=$(openssl rand -base64 32 | ${SNAP}/usr/bin/base64)
  echo "${proxy_token},system:kube-proxy,kube-proxy" >> ${SNAP_DATA}/credentials/known_tokens.csv

  ca_data=$(cat ${SNAP_DATA}/certs/ca.crt | ${SNAP}/usr/bin/base64 -w 0)
  cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/proxy.config
  chmod 660 ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i 's/NAME/kubeproxy/g' ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/proxy.config
  $SNAP/bin/sed -i 's/PASSWORD/'"${proxy_token}"'/g' ${SNAP_DATA}/credentials/proxy.config

  refresh_opt_in_config kubeconfig \${SNAP_DATA}/credentials/proxy.config kube-proxy
  skip_opt_in_config master kube-proxy
  refresh_opt_in_config token-auth-file \${SNAP_DATA}/credentials/known_tokens.csv kube-apiserver

  systemctl restart snap.${SNAP_NAME}.daemon-proxy
  need_api_restart=true
fi

if ! [ -f "$SNAP_DATA/credentials/scheduler.config" ]
then
  # Create the known tokens
  touch ${SNAP_DATA}/credentials/known_tokens.csv
  chmod 660 ${SNAP_DATA}/credentials/known_tokens.csv
  scheduler_token=$(openssl rand -base64 32 | ${SNAP}/usr/bin/base64)
  echo "${scheduler_token},system:kube-scheduler,scheduler" >> ${SNAP_DATA}/credentials/known_tokens.csv
  ca_data=$(cat ${SNAP_DATA}/certs/ca.crt | ${SNAP}/usr/bin/base64 -w 0)
  # Create the client kubeconfig for the scheduler
  cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/scheduler.config
  chmod 660 ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i 's/NAME/scheduler/g' ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/scheduler.config
  $SNAP/bin/sed -i 's/PASSWORD/'"${scheduler_token}"'/g' ${SNAP_DATA}/credentials/scheduler.config

  refresh_opt_in_config kubeconfig \${SNAP_DATA}/credentials/scheduler.config kube-scheduler
  skip_opt_in_config master kube-scheduler
  refresh_opt_in_config token-auth-file \${SNAP_DATA}/credentials/known_tokens.csv kube-apiserver

  systemctl restart snap.${SNAP_NAME}.daemon-scheduler
  need_api_restart=true
fi

if ! [ -f "$SNAP_DATA/credentials/controller.config" ]
then
  # Create the known tokens
  touch ${SNAP_DATA}/credentials/known_tokens.csv
  chmod 660 ${SNAP_DATA}/credentials/known_tokens.csv
  controller_token=$(openssl rand -base64 32 | ${SNAP}/usr/bin/base64)
  echo "${controller_token},system:kube-controller-manager,controller" >> ${SNAP_DATA}/credentials/known_tokens.csv
  ca_data=$(cat ${SNAP_DATA}/certs/ca.crt | ${SNAP}/usr/bin/base64 -w 0)

  cp ${SNAP}/client.config.template ${SNAP_DATA}/credentials/controller.config
  chmod 660 ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i 's/CADATA/'"${ca_data}"'/g' ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i 's/NAME/controller/g' ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i '/username/d' ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i 's/AUTHTYPE/token/g' ${SNAP_DATA}/credentials/controller.config
  $SNAP/bin/sed -i 's/PASSWORD/'"${controller_token}"'/g' ${SNAP_DATA}/credentials/controller.config

  refresh_opt_in_config kubeconfig \${SNAP_DATA}/credentials/controller.config kube-controller-manager
  skip_opt_in_config master kube-controller-manager
  refresh_opt_in_config use-service-account-credentials true kube-controller-manager

  refresh_opt_in_config token-auth-file \${SNAP_DATA}/credentials/known_tokens.csv kube-apiserver
  systemctl restart snap.${SNAP_NAME}.daemon-controller-manager
fi

# Securing important directories
for dir in "${SNAP_DATA}/credentials/ ${SNAP_DATA}/certs/ ${SNAP_DATA}/args/"
do
  chmod -R ug+rwX ${dir}
  chmod -R o-rwX ${dir}
done

# Try to greate the microk8s group. DO not fail the installation if something goes wrong
if ! getent group microk8s >/dev/null 2>&1
then
  groupadd --system microk8s || true
fi

if getent group microk8s >/dev/null 2>&1
then
  chgrp microk8s -R ${SNAP_DATA}/credentials/ ${SNAP_DATA}/certs/ ${SNAP_DATA}/args/ || true
fi

if grep -e "etcd.socket:2379" ${SNAP_DATA}/args/etcd
then
  echo "Using a port for etcd"
  # TODO: Do something smart in selecting a port
  refresh_opt_in_config advertise-client-urls https://\${DEFAULT_INTERFACE_IP_ADDR}:12379 etcd
  refresh_opt_in_config listen-client-urls https://0.0.0.0:12379 etcd
  refresh_opt_in_config client-cert-auth true etcd
  refresh_opt_in_config trusted-ca-file \${SNAP_DATA}/certs/ca.crt etcd
  refresh_opt_in_config cert-file \${SNAP_DATA}/certs/server.crt etcd
  refresh_opt_in_config key-file \${SNAP_DATA}/certs/server.key etcd
  systemctl restart snap.${SNAP_NAME}.daemon-etcd

  refresh_opt_in_config etcd-servers https://127.0.0.1:12379 kube-apiserver
  refresh_opt_in_config etcd-cafile \${SNAP_DATA}/certs/ca.crt kube-apiserver
  refresh_opt_in_config etcd-certfile \${SNAP_DATA}/certs/server.crt kube-apiserver
  refresh_opt_in_config etcd-keyfile \${SNAP_DATA}/certs/server.key kube-apiserver
  need_api_restart=true
fi

if ${need_api_restart}
then
  systemctl restart snap.${SNAP_NAME}.daemon-apiserver
fi

